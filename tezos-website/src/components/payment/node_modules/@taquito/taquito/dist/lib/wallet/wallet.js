"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Wallet = exports.WalletOperationBatch = void 0;
const contract_1 = require("../contract");
const types_1 = require("../operations/types");
const core_1 = require("@taquito/core");
const utils_1 = require("@taquito/utils");
class WalletOperationBatch {
    constructor(walletProvider, context) {
        this.walletProvider = walletProvider;
        this.context = context;
        this.operations = [];
    }
    /**
     * @description Add a transaction operation to the batch
     * @param params Transfer operation parameter
     */
    withTransfer(params) {
        const toValidation = (0, utils_1.validateAddress)(params.to);
        if (toValidation !== utils_1.ValidationResult.VALID) {
            throw new core_1.InvalidAddressError(params.to, (0, utils_1.invalidDetail)(toValidation));
        }
        this.operations.push(Object.assign({ kind: types_1.OpKind.TRANSACTION }, params));
        return this;
    }
    /**
     * @description Add a contract call to the batch
     * @param params Call a contract method
     * @param options Generic operation parameters
     */
    withContractCall(params, options = {}) {
        return this.withTransfer(params.toTransferParams(options));
    }
    /**
     * @description Add a delegation operation to the batch
     * @param params Delegation operation parameter
     */
    withDelegation(params) {
        var _a;
        const delegateValidation = (0, utils_1.validateAddress)((_a = params.delegate) !== null && _a !== void 0 ? _a : '');
        if (params.delegate && delegateValidation !== utils_1.ValidationResult.VALID) {
            throw new core_1.InvalidAddressError(params.delegate, (0, utils_1.invalidDetail)(delegateValidation));
        }
        this.operations.push(Object.assign({ kind: types_1.OpKind.DELEGATION }, params));
        return this;
    }
    /**
     * @description Add an origination operation to the batch
     * @param params Origination operation parameter
     */
    withOrigination(params) {
        this.operations.push(Object.assign({ kind: types_1.OpKind.ORIGINATION }, params));
        return this;
    }
    /**
     * @description Add an IncreasePaidStorage operation to the batch
     * @param param IncreasePaidStorage operation parameter
     */
    withIncreasePaidStorage(params) {
        const destinationValidation = (0, utils_1.validateAddress)(params.destination);
        if (destinationValidation !== utils_1.ValidationResult.VALID) {
            throw new core_1.InvalidAddressError(params.destination, (0, utils_1.invalidDetail)(destinationValidation));
        }
        this.operations.push(Object.assign({ kind: types_1.OpKind.INCREASE_PAID_STORAGE }, params));
        return this;
    }
    /**
     * @description Add an TransferTicket operation to the batch
     * @param param TransferTicket operation parameter
     */
    withTransferTicket(params) {
        const destinationValidation = (0, utils_1.validateAddress)(params.destination);
        if (destinationValidation !== utils_1.ValidationResult.VALID) {
            throw new core_1.InvalidAddressError(params.destination, (0, utils_1.invalidDetail)(destinationValidation));
        }
        this.operations.push(Object.assign({ kind: types_1.OpKind.TRANSFER_TICKET }, params));
        return this;
    }
    mapOperation(param) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (param.kind) {
                case types_1.OpKind.TRANSACTION:
                    return this.walletProvider.mapTransferParamsToWalletParams(() => __awaiter(this, void 0, void 0, function* () { return param; }));
                case types_1.OpKind.ORIGINATION:
                    return this.walletProvider.mapOriginateParamsToWalletParams(() => __awaiter(this, void 0, void 0, function* () {
                        return this.context.parser.prepareCodeOrigination(Object.assign({}, param));
                    }));
                case types_1.OpKind.DELEGATION:
                    return this.walletProvider.mapDelegateParamsToWalletParams(() => __awaiter(this, void 0, void 0, function* () { return param; }));
                case types_1.OpKind.INCREASE_PAID_STORAGE:
                    return this.walletProvider.mapIncreasePaidStorageWalletParams(() => __awaiter(this, void 0, void 0, function* () { return param; }));
                default:
                    throw new core_1.InvalidOperationKindError(JSON.stringify(param.kind));
            }
        });
    }
    /**
     * @description Add a group operation to the batch. Operation will be applied in the order they are in the params array
     * @param params Operations parameter
     * @throws {@link InvalidOperationKindError}
     */
    with(params) {
        for (const param of params) {
            switch (param.kind) {
                case types_1.OpKind.TRANSACTION:
                    this.withTransfer(param);
                    break;
                case types_1.OpKind.ORIGINATION:
                    this.withOrigination(param);
                    break;
                case types_1.OpKind.DELEGATION:
                    this.withDelegation(param);
                    break;
                case types_1.OpKind.INCREASE_PAID_STORAGE:
                    this.withIncreasePaidStorage(param);
                    break;
                default:
                    throw new core_1.InvalidOperationKindError(JSON.stringify(param.kind));
            }
        }
        return this;
    }
    /**
     * @description Submit batch operation to wallet
     */
    send() {
        return __awaiter(this, void 0, void 0, function* () {
            const ops = [];
            for (const op of this.operations) {
                ops.push(yield this.mapOperation(op));
            }
            const opHash = yield this.walletProvider.sendOperations(ops);
            return this.context.operationFactory.createBatchOperation(opHash);
        });
    }
}
exports.WalletOperationBatch = WalletOperationBatch;
class Wallet {
    constructor(context) {
        this.context = context;
        this.walletCommand = (send) => {
            return {
                send,
            };
        };
    }
    get walletProvider() {
        return this.context.walletProvider;
    }
    /**
     * @description Retrieve the PKH of the account that is currently in use by the wallet
     * @param option Option to use while fetching the PKH.
     * If forceRefetch is specified the wallet provider implementation will refetch the PKH from the wallet
     */
    pkh() {
        return __awaiter(this, arguments, void 0, function* ({ forceRefetch } = {}) {
            if (!this._pkh || forceRefetch) {
                this._pkh = yield this.walletProvider.getPKH();
            }
            return this._pkh;
        });
    }
    /**
     * @description Retrieve the PK of the account that is currently in use by the wallet
     * @param option Option to use while fetching the PK.
     * If forceRefetch is specified the wallet provider implementation will refetch the PK from the wallet
     */
    pk() {
        return __awaiter(this, arguments, void 0, function* ({ forceRefetch } = {}) {
            if (!this._pk || forceRefetch) {
                this._pk = yield this.walletProvider.getPK();
            }
            return this._pk;
        });
    }
    /**
     * @description Originate a new contract according to the script in parameters.
     * @returns a OriginationWalletOperation promise object when followed by .send()
     * @param originateParams Originate operation parameter
     */
    originate(params) {
        return this.walletCommand(() => __awaiter(this, void 0, void 0, function* () {
            const mappedParams = yield this.walletProvider.mapOriginateParamsToWalletParams(() => this.context.parser.prepareCodeOrigination(Object.assign({}, params)));
            const opHash = yield this.walletProvider.sendOperations([mappedParams]);
            return this.context.operationFactory.createOriginationOperation(opHash);
        }));
    }
    /**
     * @description Set the delegate for a contract.
     * @returns a WalletDelegateParams promise object when followed by .send()
     * @param delegateParams operation parameter
     */
    setDelegate(params) {
        var _a;
        const delegateValidation = (0, utils_1.validateAddress)((_a = params.delegate) !== null && _a !== void 0 ? _a : '');
        if (params.delegate && delegateValidation !== utils_1.ValidationResult.VALID) {
            throw new core_1.InvalidAddressError(params.delegate, (0, utils_1.invalidDetail)(delegateValidation));
        }
        return this.walletCommand(() => __awaiter(this, void 0, void 0, function* () {
            const mappedParams = yield this.walletProvider.mapDelegateParamsToWalletParams(() => __awaiter(this, void 0, void 0, function* () { return params; }));
            const opHash = yield this.walletProvider.sendOperations([mappedParams]);
            return this.context.operationFactory.createDelegationOperation(opHash);
        }));
    }
    /**
     * @description failing_noop operation that is guaranteed to fail. DISCLAIMER: Not all wallets support signing failing_noop operations.
     * @returns Signature for a failing_noop
     * @param params operation parameter
     */
    signFailingNoop(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const op = {
                kind: types_1.OpKind.FAILING_NOOP,
                arbitrary: params.arbitrary,
            };
            const hash = yield this.context.readProvider.getBlockHash(params.basedOnBlock);
            const forgedBytes = yield this.context.forger.forge({
                branch: hash,
                contents: [op],
            });
            const signature = yield this.walletProvider.sign(forgedBytes, Uint8Array.from([3]));
            return {
                signature,
                bytes: forgedBytes,
                signedContent: {
                    branch: hash,
                    contents: [
                        {
                            kind: types_1.OpKind.FAILING_NOOP,
                            arbitrary: params.arbitrary,
                        },
                    ],
                },
            };
        });
    }
    /**
     * @description Register the current address as delegate.
     * @returns a DelegationWalletOperation promise object when followed by .send()
     */
    registerDelegate() {
        return this.walletCommand(() => __awaiter(this, void 0, void 0, function* () {
            const mappedParams = yield this.walletProvider.mapDelegateParamsToWalletParams(() => __awaiter(this, void 0, void 0, function* () {
                const delegate = yield this.pkh();
                return { delegate };
            }));
            const opHash = yield this.walletProvider.sendOperations([mappedParams]);
            return this.context.operationFactory.createDelegationOperation(opHash);
        }));
    }
    /**
     * @description Transfer tezos tokens from current address to a specific address or call a smart contract.
     * @returns a TransactionWalletOperation promise object when followed by .send()
     * @param params operation parameter
     */
    transfer(params) {
        const toValidation = (0, utils_1.validateAddress)(params.to);
        if (toValidation !== utils_1.ValidationResult.VALID) {
            throw new core_1.InvalidAddressError(params.to, (0, utils_1.invalidDetail)(toValidation));
        }
        return this.walletCommand(() => __awaiter(this, void 0, void 0, function* () {
            const mappedParams = yield this.walletProvider.mapTransferParamsToWalletParams(() => __awaiter(this, void 0, void 0, function* () { return params; }));
            const opHash = yield this.walletProvider.sendOperations([mappedParams]);
            return this.context.operationFactory.createTransactionOperation(opHash);
        }));
    }
    /**
     * @description Transfer tezos tickets from current address to a specific address or a smart contract
     * @returns a TransferTicketWalletOperation promise object when followed by .send()
     * @param params operation parameter
     */
    transferTicket(params) {
        const toValidation = (0, utils_1.validateAddress)(params.destination);
        if (toValidation !== utils_1.ValidationResult.VALID) {
            throw new core_1.InvalidAddressError(params.destination, (0, utils_1.invalidDetail)(toValidation));
        }
        return this.walletCommand(() => __awaiter(this, void 0, void 0, function* () {
            const mappedParams = yield this.walletProvider.mapTransferTicketParamsToWalletParams(() => __awaiter(this, void 0, void 0, function* () { return params; }));
            const opHash = yield this.walletProvider.sendOperations([mappedParams]);
            return this.context.operationFactory.createTransferTicketOperation(opHash);
        }));
    }
    /**
     * @description Stake a given amount for the source address
     * @returns a TransactionWalletOperation promise object when followed by .send()
     * @param Stake pseudo-operation parameter
     */
    stake(params) {
        return this.walletCommand(() => __awaiter(this, void 0, void 0, function* () {
            const mappedParams = yield this.walletProvider.mapStakeParamsToWalletParams(() => __awaiter(this, void 0, void 0, function* () {
                const source = yield this.pkh();
                if (!params.to) {
                    params.to = source;
                }
                if (params.to !== source) {
                    throw new core_1.InvalidStakingAddressError(params.to);
                }
                params.parameter = { entrypoint: 'stake', value: { prim: 'Unit' } };
                return params;
            }));
            const opHash = yield this.walletProvider.sendOperations([mappedParams]);
            return this.context.operationFactory.createTransactionOperation(opHash);
        }));
    }
    /**
     * @description Unstake the given amount. If "everything" is given as amount, unstakes everything from the staking balance.
     * Unstaked tez remains frozen for a set amount of cycles (the slashing period) after the operation. Once this period is over,
     * the operation "finalize unstake" must be called for the funds to appear in the liquid balance.
     * @returns a TransactionWalletOperation promise object when followed by .send()
     * @param Unstake pseudo-operation parameter
     */
    unstake(params) {
        return this.walletCommand(() => __awaiter(this, void 0, void 0, function* () {
            const mappedParams = yield this.walletProvider.mapUnstakeParamsToWalletParams(() => __awaiter(this, void 0, void 0, function* () {
                const source = yield this.pkh();
                if (!params.to) {
                    params.to = source;
                }
                if (params.to !== source) {
                    throw new core_1.InvalidStakingAddressError(params.to);
                }
                params.parameter = { entrypoint: 'unstake', value: { prim: 'Unit' } };
                return params;
            }));
            const opHash = yield this.walletProvider.sendOperations([mappedParams]);
            return yield this.context.operationFactory.createTransactionOperation(opHash);
        }));
    }
    /**
     * @description Transfer all the finalizable unstaked funds of the source to their liquid balance
     * @returns a TransactionWalletOperation promise object when followed by .send()
     * @param Finalize_unstake pseudo-operation parameter
     */
    finalizeUnstake(params) {
        return this.walletCommand(() => __awaiter(this, void 0, void 0, function* () {
            const mappedParams = yield this.walletProvider.mapFinalizeUnstakeParamsToWalletParams(() => __awaiter(this, void 0, void 0, function* () {
                const source = yield this.pkh();
                if (!params.to) {
                    params.to = source;
                }
                if (params.to !== source) {
                    throw new core_1.InvalidStakingAddressError(params.to);
                }
                if (!params.amount) {
                    params.amount = 0;
                }
                if (params.amount !== 0) {
                    throw new core_1.InvalidFinalizeUnstakeAmountError('Amount must be 0 to finalize unstake.');
                }
                params.parameter = { entrypoint: 'finalize_unstake', value: { prim: 'Unit' } };
                return params;
            }));
            const opHash = yield this.walletProvider.sendOperations([mappedParams]);
            return yield this.context.operationFactory.createTransactionOperation(opHash);
        }));
    }
    /**
     * @description Increase the paid storage of a smart contract.
     * @returns a IncreasePaidStorageWalletOperation promise object when followed by .send()
     * @param params operation parameter
     */
    increasePaidStorage(params) {
        const destinationValidation = (0, utils_1.validateAddress)(params.destination);
        if (destinationValidation !== utils_1.ValidationResult.VALID) {
            throw new core_1.InvalidAddressError(params.destination, (0, utils_1.invalidDetail)(destinationValidation));
        }
        return this.walletCommand(() => __awaiter(this, void 0, void 0, function* () {
            const mappedParams = yield this.walletProvider.mapIncreasePaidStorageWalletParams(() => __awaiter(this, void 0, void 0, function* () { return params; }));
            const opHash = yield this.walletProvider.sendOperations([mappedParams]);
            return this.context.operationFactory.createIncreasePaidStorageOperation(opHash);
        }));
    }
    /**
     * @description Create a batch of operation
     * @returns A batch object from which we can add more operation or send a command to the wallet to execute the batch
     * @param params List of operation to initialize the batch with
     */
    batch(params) {
        const batch = new WalletOperationBatch(this.walletProvider, this.context);
        if (Array.isArray(params)) {
            batch.with(params);
        }
        return batch;
    }
    /**
     * @description Create an smart contract abstraction for the address specified. Calling entrypoints with the returned
     * smart contract abstraction will leverage the wallet provider to make smart contract calls
     * @param address Smart contract address
     * @throws {@link InvalidContractAddressError} If the contract address is not valid
     */
    at(address_1) {
        return __awaiter(this, arguments, void 0, function* (address, contractAbstractionComposer = (x) => x) {
            const addressValidation = (0, utils_1.validateContractAddress)(address);
            if (addressValidation !== utils_1.ValidationResult.VALID) {
                throw new core_1.InvalidContractAddressError(address, (0, utils_1.invalidDetail)(addressValidation));
            }
            const rpc = this.context.withExtensions().rpc;
            const readProvider = this.context.withExtensions().readProvider;
            const script = yield readProvider.getScript(address, 'head');
            const entrypoints = yield readProvider.getEntrypoints(address);
            const abs = new contract_1.ContractAbstraction(address, script, this, this.context.contract, entrypoints, rpc, readProvider);
            return contractAbstractionComposer(abs, this.context);
        });
    }
    /**
     * @deprecated Deprecated in favor of {@link Wallet.pk} will be removed in v19.1
     * @description Retrieve the PK of the account that is currently in use by the wallet
     */
    getPK() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.pk();
        });
    }
}
exports.Wallet = Wallet;
