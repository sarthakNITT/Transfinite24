"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSmartRollupExecuteOutboxMessageOperation = exports.createSmartRollupOriginateOperation = exports.createSmartRollupAddMessagesOperation = exports.createUpdateConsensusKeyOperation = exports.createProposalsOperation = exports.createBallotOperation = exports.createDrainDelegateOperation = exports.createIncreasePaidStorageOperation = exports.createTransferTicketOperation = exports.createRegisterGlobalConstantOperation = exports.createRevealOperation = exports.createRegisterDelegateOperation = exports.createSetDelegateOperation = exports.createTransferOperation = exports.createOriginationOperation = exports.createActivationOperation = void 0;
const michelson_encoder_1 = require("@taquito/michelson-encoder");
const rpc_1 = require("@taquito/rpc");
const constants_1 = require("../constants");
const utils_1 = require("@taquito/utils");
const errors_1 = require("./errors");
const createActivationOperation = (_a) => __awaiter(void 0, [_a], void 0, function* ({ pkh, secret }) {
    return {
        kind: rpc_1.OpKind.ACTIVATION,
        pkh,
        secret,
    };
});
exports.createActivationOperation = createActivationOperation;
const createOriginationOperation = (_a) => __awaiter(void 0, [_a], void 0, function* ({ code, init, balance = '0', delegate, storage, fee, gasLimit, storageLimit, mutez = false, }) {
    if (storage !== undefined && init !== undefined) {
        throw new errors_1.OriginationParameterError('Storage and Init cannot be set a the same time. Please either use storage or init but not both.');
    }
    if (!Array.isArray(code)) {
        throw new errors_1.InvalidCodeParameter('Wrong code parameter type, expected an array', code);
    }
    let contractStorage;
    if (storage !== undefined) {
        const storageType = code.find((p) => 'prim' in p && p.prim === 'storage');
        if ((storageType === null || storageType === void 0 ? void 0 : storageType.args) === undefined) {
            throw new errors_1.InvalidCodeParameter('The storage section is missing from the script', code);
        }
        const schema = new michelson_encoder_1.Schema(storageType.args[0]); // TODO
        contractStorage = schema.Encode(storage);
    }
    else if (init !== undefined && typeof init === 'object') {
        contractStorage = init;
    }
    else {
        throw new errors_1.InvalidInitParameter('Wrong init parameter type, expected JSON Michelson', init);
    }
    const script = {
        code,
        storage: contractStorage,
    };
    if (isNaN(Number(balance))) {
        throw new errors_1.InvalidBalanceError(`Invalid Balance "${balance}", cannot be converted to a number`);
    }
    const operation = {
        kind: rpc_1.OpKind.ORIGINATION,
        fee,
        gas_limit: gasLimit,
        storage_limit: storageLimit,
        balance: mutez ? balance.toString() : (0, utils_1.format)('tz', 'mutez', balance).toString(),
        script,
    };
    if (delegate) {
        operation.delegate = delegate;
    }
    return operation;
});
exports.createOriginationOperation = createOriginationOperation;
const createTransferOperation = (_a) => __awaiter(void 0, [_a], void 0, function* ({ to, amount, parameter, fee, gasLimit, storageLimit, mutez = false, }) {
    return {
        kind: rpc_1.OpKind.TRANSACTION,
        fee,
        gas_limit: gasLimit,
        storage_limit: storageLimit,
        amount: mutez ? amount.toString() : (0, utils_1.format)('tz', 'mutez', amount).toString(),
        destination: to,
        parameters: parameter,
    };
});
exports.createTransferOperation = createTransferOperation;
const createSetDelegateOperation = (_a) => __awaiter(void 0, [_a], void 0, function* ({ delegate, source, fee, gasLimit, storageLimit, }) {
    const operation = {
        kind: rpc_1.OpKind.DELEGATION,
        source,
        fee,
        gas_limit: gasLimit,
        storage_limit: storageLimit,
        delegate,
    };
    return operation;
});
exports.createSetDelegateOperation = createSetDelegateOperation;
const createRegisterDelegateOperation = (_a, source_1) => __awaiter(void 0, [_a, source_1], void 0, function* ({ fee, gasLimit, storageLimit }, source) {
    return {
        kind: rpc_1.OpKind.DELEGATION,
        fee,
        gas_limit: gasLimit,
        storage_limit: storageLimit,
        delegate: source,
    };
});
exports.createRegisterDelegateOperation = createRegisterDelegateOperation;
const createRevealOperation = (_a, source_1, publicKey_1) => __awaiter(void 0, [_a, source_1, publicKey_1], void 0, function* ({ fee, gasLimit, storageLimit }, source, publicKey) {
    return {
        kind: rpc_1.OpKind.REVEAL,
        fee,
        public_key: publicKey,
        source,
        gas_limit: gasLimit !== null && gasLimit !== void 0 ? gasLimit : (0, constants_1.getRevealGasLimit)(source),
        storage_limit: storageLimit,
    };
});
exports.createRevealOperation = createRevealOperation;
const createRegisterGlobalConstantOperation = (_a) => __awaiter(void 0, [_a], void 0, function* ({ value, source, fee, gasLimit, storageLimit, }) {
    return {
        kind: rpc_1.OpKind.REGISTER_GLOBAL_CONSTANT,
        value,
        fee,
        gas_limit: gasLimit,
        storage_limit: storageLimit,
        source,
    };
});
exports.createRegisterGlobalConstantOperation = createRegisterGlobalConstantOperation;
const createTransferTicketOperation = (_a) => __awaiter(void 0, [_a], void 0, function* ({ ticketContents, ticketTy, ticketTicketer, ticketAmount, destination, entrypoint, source, fee, gasLimit, storageLimit, }) {
    return {
        kind: rpc_1.OpKind.TRANSFER_TICKET,
        fee,
        gas_limit: gasLimit,
        storage_limit: storageLimit,
        source,
        ticket_contents: ticketContents,
        ticket_ty: ticketTy,
        ticket_ticketer: ticketTicketer,
        ticket_amount: ticketAmount,
        destination,
        entrypoint,
    };
});
exports.createTransferTicketOperation = createTransferTicketOperation;
const createIncreasePaidStorageOperation = (_a) => __awaiter(void 0, [_a], void 0, function* ({ source, fee, gasLimit, storageLimit, amount, destination, }) {
    return {
        kind: rpc_1.OpKind.INCREASE_PAID_STORAGE,
        source,
        fee,
        gas_limit: gasLimit,
        storage_limit: storageLimit,
        amount,
        destination,
    };
});
exports.createIncreasePaidStorageOperation = createIncreasePaidStorageOperation;
const createDrainDelegateOperation = (_a) => __awaiter(void 0, [_a], void 0, function* ({ consensus_key, delegate, destination, }) {
    return {
        kind: rpc_1.OpKind.DRAIN_DELEGATE,
        consensus_key,
        delegate,
        destination,
    };
});
exports.createDrainDelegateOperation = createDrainDelegateOperation;
const createBallotOperation = (_a) => __awaiter(void 0, [_a], void 0, function* ({ source, proposal, ballot }) {
    return {
        kind: rpc_1.OpKind.BALLOT,
        source,
        proposal,
        ballot,
    };
});
exports.createBallotOperation = createBallotOperation;
const createProposalsOperation = (_a) => __awaiter(void 0, [_a], void 0, function* ({ source, proposals }) {
    return {
        kind: rpc_1.OpKind.PROPOSALS,
        source,
        proposals,
    };
});
exports.createProposalsOperation = createProposalsOperation;
const createUpdateConsensusKeyOperation = (_a) => __awaiter(void 0, [_a], void 0, function* ({ source, fee, gasLimit, storageLimit, pk, }) {
    return {
        kind: rpc_1.OpKind.UPDATE_CONSENSUS_KEY,
        source,
        fee,
        gas_limit: gasLimit,
        storage_limit: storageLimit,
        pk,
    };
});
exports.createUpdateConsensusKeyOperation = createUpdateConsensusKeyOperation;
const createSmartRollupAddMessagesOperation = (_a) => __awaiter(void 0, [_a], void 0, function* ({ source, fee, gasLimit, storageLimit, message, }) {
    return {
        kind: rpc_1.OpKind.SMART_ROLLUP_ADD_MESSAGES,
        source,
        fee,
        gas_limit: gasLimit,
        storage_limit: storageLimit,
        message,
    };
});
exports.createSmartRollupAddMessagesOperation = createSmartRollupAddMessagesOperation;
const createSmartRollupOriginateOperation = (_a) => __awaiter(void 0, [_a], void 0, function* ({ source, fee, gasLimit, storageLimit, pvmKind, kernel, parametersType, }) {
    return {
        kind: rpc_1.OpKind.SMART_ROLLUP_ORIGINATE,
        source,
        fee,
        gas_limit: gasLimit,
        storage_limit: storageLimit,
        pvm_kind: pvmKind,
        kernel,
        parameters_ty: parametersType,
    };
});
exports.createSmartRollupOriginateOperation = createSmartRollupOriginateOperation;
const createSmartRollupExecuteOutboxMessageOperation = (_a) => __awaiter(void 0, [_a], void 0, function* ({ source, fee, gasLimit, storageLimit, rollup, cementedCommitment, outputProof, }) {
    return {
        kind: rpc_1.OpKind.SMART_ROLLUP_EXECUTE_OUTBOX_MESSAGE,
        source,
        fee,
        gas_limit: gasLimit,
        storage_limit: storageLimit,
        rollup,
        cemented_commitment: cementedCommitment,
        output_proof: outputProof,
    };
});
exports.createSmartRollupExecuteOutboxMessageOperation = createSmartRollupExecuteOutboxMessageOperation;
